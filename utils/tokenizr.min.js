const excerpt=(t,e)=>{const i=t.length;let n=e-20;n<0&&(n=0);let s=e+20;s>i&&(s=i);const r=t=>t.charCodeAt(0).toString(16).toUpperCase(),o=(t,e,i)=>t.substr(e,i).replace(/\\/g,"\\\\").replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g,(t=>"\\x0"+r(t))).replace(/[\x10-\x1F\x80-\xFF]/g,(t=>"\\x"+r(t))).replace(/[\u0100-\u0FFF]/g,(t=>"\\u0"+r(t))).replace(/[\u1000-\uFFFF]/g,(t=>"\\u"+r(t)));return{prologTrunc:n>0,prologText:o(t,n,e-n),tokenText:o(t,e,1),epilogText:o(t,e+1,s-(e+1)),epilogTrunc:s<i}};class Token{constructor(t,e,i,n=0,s=0,r=0){this.type=t,this.value=e,this.text=i,this.pos=n,this.line=s,this.column=r}toString(t=((t,e)=>e)){return`${t("type",this.type)} (value: ${t("value",JSON.stringify(this.value))}, text: ${t("text",JSON.stringify(this.text))}, pos: ${t("pos",this.pos)}, line: ${t("line",this.line)}, column: ${t("column",this.column)})`}toJSON(t=((t,e)=>e)){return{type:t("type",this.type),value:t("value",JSON.stringify(this.value)),text:t("text",JSON.stringify(this.text)),pos:t("pos",this.pos),line:t("line",this.line),column:t("column",this.column)}}isA(t,e){return t===this.type&&(2!==arguments.length||e===this.value)}}class ParsingError extends Error{constructor(t,e,i,n,s){super(t),this.name="ParsingError",this.message=t,this.pos=e,this.line=i,this.column=n,this.input=s}toString(){const t=excerpt(this.input,this.pos),e=`line ${this.line} (column ${this.column}): `;let i="";for(let n=0;n<e.length+t.prologText.length;n++)i+=" ";return"Parsing Error: "+this.message+"\n"+e+t.prologText+t.tokenText+t.epilogText+"\n"+i+"^"}}class ActionContext{constructor(t){this._tokenizr=t,this._data={},this._repeat=!1,this._reject=!1,this._ignore=!1,this._match=null}data(t,e){const i=this._data[t];return 2===arguments.length&&(this._data[t]=e),i}info(){return{line:this._tokenizr._line,column:this._tokenizr._column,pos:this._tokenizr._pos,len:this._match[0].length}}push(...t){return this._tokenizr.push(...t),this}pop(...t){return this._tokenizr.pop(...t)}state(...t){return t.length>0?(this._tokenizr.state(...t),this):this._tokenizr.state(...t)}tag(...t){return this._tokenizr.tag(...t),this}tagged(...t){return this._tokenizr.tagged(...t)}untag(...t){return this._tokenizr.untag(...t),this}repeat(){return this._tokenizr._log("    REPEAT"),this._repeat=!0,this}reject(){return this._tokenizr._log("    REJECT"),this._reject=!0,this}ignore(){return this._tokenizr._log("    IGNORE"),this._ignore=!0,this}accept(t,e){return arguments.length<2&&(e=this._match[0]),this._tokenizr._log(`    ACCEPT: type: ${t}, value: ${JSON.stringify(e)} (${typeof e}), text: "${this._match[0]}"`),this._tokenizr._pending.push(new Token(t,e,this._match[0],this._tokenizr._pos,this._tokenizr._line,this._tokenizr._column)),this}stop(){return this._tokenizr._stopped=!0,this}}window.Tokenizr=class{constructor(){this._before=null,this._after=null,this._finish=null,this._rules=[],this._debug=!1,this.reset()}reset(){return this._input="",this._len=0,this._eof=!1,this._pos=0,this._line=1,this._column=1,this._state=["default"],this._tag={},this._transaction=[],this._pending=[],this._stopped=!1,this._ctx=new ActionContext(this),this}error(t){return new ParsingError(t,this._pos,this._line,this._column,this._input)}debug(t){return this._debug=t,this}_log(t){this._debug}input(t){if("string"!=typeof t)throw new Error('parameter "input" not a String');return this.reset(),this._input=t,this._len=t.length,this}push(t){if(1!==arguments.length)throw new Error("invalid number of arguments");if("string"!=typeof t)throw new Error('parameter "state" not a String');return this._log(`    STATE (PUSH): old: <${this._state[this._state.length-1]}>, new: <${t}>`),this._state.push(t),this}pop(){if(0!==arguments.length)throw new Error("invalid number of arguments");if(this._state.length<2)throw new Error("no more custom states to pop");return this._log(`    STATE (POP): old: <${this._state[this._state.length-1]}>, new: <${this._state[this._state.length-2]}>`),this._state.pop()}state(t){if(1===arguments.length){if("string"!=typeof t)throw new Error('parameter "state" not a String');return this._log(`    STATE (SET): old: <${this._state[this._state.length-1]}>, new: <${t}>`),this._state[this._state.length-1]=t,this}if(0===arguments.length)return this._state[this._state.length-1];throw new Error("invalid number of arguments")}tag(t){if(1!==arguments.length)throw new Error("invalid number of arguments");if("string"!=typeof t)throw new Error('parameter "tag" not a String');return this._log(`    TAG (ADD): ${t}`),this._tag[t]=!0,this}tagged(t){if(1!==arguments.length)throw new Error("invalid number of arguments");if("string"!=typeof t)throw new Error('parameter "tag" not a String');return!0===this._tag[t]}untag(t){if(1!==arguments.length)throw new Error("invalid number of arguments");if("string"!=typeof t)throw new Error('parameter "tag" not a String');return this._log(`    TAG (DEL): ${t}`),delete this._tag[t],this}before(t){return this._before=t,this}after(t){return this._after=t,this}finish(t){return this._finish=t,this}rule(t,e,i,n="unknown"){if(2===arguments.length&&"function"==typeof e?([e,i]=[t,e],t="*"):3===arguments.length&&"function"==typeof e&&([e,i,n]=[t,e,i],t="*"),"string"!=typeof t)throw new Error('parameter "state" not a String');if(!("object"==typeof e&&e instanceof RegExp))throw new Error('parameter "pattern" not a RegExp');if("function"!=typeof i)throw new Error('parameter "action" not a Function');if("string"!=typeof n)throw new Error('parameter "name" not a String');t=t.split(/\s*,\s*/g).map((t=>{const e=t.split(/\s+/g),i=e.filter((t=>null===t.match(/^#/))),n=e.filter((t=>null!==t.match(/^#/))).map((t=>t.replace(/^#/,"")));if(1!==i.length)throw new Error("exactly one state required");return{state:i[0],tags:n}}));let s="g";try{"boolean"==typeof new RegExp("","y").sticky&&(s="y")}catch(t){}return"boolean"==typeof e.multiline&&e.multiline&&(s+="m"),"boolean"==typeof e.dotAll&&e.dotAll&&(s+="s"),"boolean"==typeof e.ignoreCase&&e.ignoreCase&&(s+="i"),"boolean"==typeof e.unicode&&e.unicode&&(s+="u"),e=new RegExp(e.source,s),this._log(`rule: configure rule (state: ${t}, pattern: ${e.source})`),this._rules.push({state:t,pattern:e,action:i,name:n}),this}_progress(t,e){const i=this._line,n=this._column,s=this._input;for(let i=t;i<e;i++){const t=s.charAt(i);"\r"===t?this._column=1:"\n"===t?(this._line++,this._column=1):"\t"===t?this._column+=8-this._column%8:this._column++}this._log(`    PROGRESS: characters: ${e-t}, from: <line ${i}, column ${n}>, to: <line ${this._line}, column ${this._column}>`)}_tokenize(){const t=()=>{this._eof||(null!==this._finish&&this._finish.call(this._ctx,this._ctx),this._eof=!0,this._pending.push(new Token("EOF","","",this._pos,this._line,this._column)))};if(this._stopped||this._pos>=this._len)return void t();let e=!0;for(;e;){if(e=!1,this._debug){const t=excerpt(this._input,this._pos),e=Object.keys(this._tag).map((t=>`#${t}`)).join(" ");this._log(`INPUT: state: <${this._state[this._state.length-1]}>, tags: <${e}>, text: `+(t.prologTrunc?"...":'"')+`${t.prologText}<${t.tokenText}>${t.epilogText}`+(t.epilogTrunc?"...":'"')+`, at: <line ${this._line}, column ${this._column}>`)}for(let i=0;i<this._rules.length;i++){if(this._debug){const t=this._rules[i].state.map((t=>{let e=t.state;return t.tags.length>0&&(e+=" "+t.tags.map((t=>`#${t}`)).join(" ")),e})).join(", ");this._log(`  RULE: state(s): <${t}>, pattern: ${this._rules[i].pattern.source}`)}let n=!1;const s=this._rules[i].state.map((t=>t.state));let r=s.indexOf("*");if(r<0&&(r=s.indexOf(this._state[this._state.length-1])),r>=0){n=!0;let t=this._rules[i].state[r].tags;t=t.filter((t=>!this._tag[t])),t.length>0&&(n=!1)}if(!n)continue;this._rules[i].pattern.lastIndex=this._pos;let o=this._rules[i].pattern.exec(this._input);if(this._rules[i].pattern.lastIndex=this._pos,null!==(o=this._rules[i].pattern.exec(this._input))&&o.index===this._pos){if(this._debug&&this._log("    MATCHED: "+JSON.stringify(o)),this._ctx._match=o,this._ctx._repeat=!1,this._ctx._reject=!1,this._ctx._ignore=!1,null!==this._before&&this._before.call(this._ctx,this._ctx,o,this._rules[i]),this._rules[i].action.call(this._ctx,this._ctx,o),null!==this._after&&this._after.call(this._ctx,this._ctx,o,this._rules[i]),this._ctx._reject)continue;if(this._ctx._repeat){e=!0;break}if(this._ctx._ignore){if(this._progress(this._pos,this._rules[i].pattern.lastIndex),this._pos=this._rules[i].pattern.lastIndex,this._pos>=this._len)return void t();e=!0;break}if(this._pending.length>0)return this._progress(this._pos,this._rules[i].pattern.lastIndex),this._pos=this._rules[i].pattern.lastIndex,void(this._pos>=this._len&&t());throw new Error('action of pattern "'+this._rules[i].pattern.source+'" neither rejected nor accepted any token(s)')}}}throw this.error("token not recognized")}token(){if(0===this._pending.length&&this._tokenize(),this._pending.length>0){const t=this._pending.shift();return this._transaction.length>0&&this._transaction[0].push(t),this._log(`TOKEN: ${t.toString()}`),t}return null}tokens(){const t=[];let e;for(;null!==(e=this.token());)t.push(e);return t}peek(t){if(void 0===t&&(t=0),t>=this._pending.length){0===this._pending.length&&this._tokenize();for(let e=0;e<t-this._pending.length;e++)this._tokenize()}if(t>=this._pending.length)throw new Error("not enough tokens available for peek operation");return this._log(`PEEK: ${this._pending[t].toString()}`),this._pending[t]}skip(t){void 0===t&&(t=1);for(let e=0;e<this._pending.length+t;e++)this._tokenize();if(t>this._pending.length)throw new Error("not enough tokens available for skip operation");for(;t-- >0;)this.token();return this}consume(t,e){for(let t=0;t<this._pending.length+1;t++)this._tokenize();if(0===this._pending.length)throw new Error("not enough tokens available for consume operation");const i=this.token();this._log(`CONSUME: ${i.toString()}`);const n=()=>{throw new ParsingError(`expected: <type: ${t}, value: ${JSON.stringify(e)} (${typeof e})>, found: <type: ${i.type}, value: ${JSON.stringify(i.value)} (${typeof i.value})>`,i.pos,i.line,i.column,this._input)};return 2!==arguments.length||i.isA(t,e)?i.isA(t)||n():n(JSON.stringify(e)),i}begin(){return this._log(`BEGIN: level ${this._transaction.length}`),this._transaction.unshift([]),this}depth(){if(0===this._transaction.length)throw new Error("cannot determine depth -- no active transaction");return this._transaction[0].length}commit(){if(0===this._transaction.length)throw new Error("cannot commit transaction -- no active transaction");const t=this._transaction.shift();return this._transaction.length>0&&(this._transaction[0]=this._transaction[0].concat(t)),this._log(`COMMIT: level ${this._transaction.length}`),this}rollback(){if(0===this._transaction.length)throw new Error("cannot rollback transaction -- no active transaction");const t=this._transaction.shift();return this._pending=t.concat(this._pending),this._log(`ROLLBACK: level ${this._transaction.length}`),this}alternatives(...t){let e=null,i=[];for(let n=0;n<t.length;n++)try{this.begin(),e=t[n].call(this),this.commit();break}catch(t){this._log(`EXCEPTION: ${t.toString()}`),i.push({ex:t,depth:this.depth()}),this.rollback();continue}if(null===e&&i.length>0)throw i=i.sort(((t,e)=>t.depth-e.depth)),i[0].ex;return e}},Tokenizr.Token=Token,Tokenizr.ParsingError=ParsingError,Tokenizr.ActionContext=ActionContext;